This example shows the implementation of New Order message used on London Stock Exchange. For the complete specification see
[Native Trading Gateway](https://docs.londonstockexchange.com/sites/default/files/documents/mit203_-_native_trading_gateway_specification_-_issue_17.0_2.pdf)

The generated code is identified by the attribute
```cpp 
[[cppgen::auto]]
```

For example, the following is the hand-written definition of Order Type enumeration. 
```cpp 
enum class OrderType : uint8_t
{
    Market    = 1,
    Limit     = 2,
    Stop      = 3,
    StopLimit = 4
};
```

Below is the code generated by 'cppgen.nvim' using default configuration.

```cpp 
inline [[cppgen::auto]] std::ostream& operator<<(std::ostream& s, OrderType o)
{
    switch (o) {
        // clang-format off
        case OrderType::Market:    s << "1(Market)";    break;
        case OrderType::Limit:     s << "2(Limit)";     break;
        case OrderType::Stop:      s << "3(Stop)";      break;
        case OrderType::StopLimit: s << "4(StopLimit)"; break;
        default: s << std::to_string(static_cast<std::underlying_type_t<OrderType>>(o)) + "(Invalid OrderType)"; break;
        // clang-format on
    };
    return s;
}

inline [[cppgen::auto]] std::string to_json(OrderType o, bool verbose)
{
    if (verbose) {
        switch(o)
        {
        // clang-format off
            case OrderType::Market:    return to_json("1(Market)"   , verbose); break;
            case OrderType::Limit:     return to_json("2(Limit)"    , verbose); break;
            case OrderType::Stop:      return to_json("3(Stop)"     , verbose); break;
            case OrderType::StopLimit: return to_json("4(StopLimit)", verbose); break;
            default: return to_json(std::to_string(static_cast<std::underlying_type_t<OrderType>>(o)) + "(Invalid OrderType)", verbose); break;
        // clang-format on
        };
    } else {
        switch(o)
        {
        // clang-format off
            case OrderType::Market:    return to_json(1, verbose); break;
            case OrderType::Limit:     return to_json(2, verbose); break;
            case OrderType::Stop:      return to_json(3, verbose); break;
            case OrderType::StopLimit: return to_json(4, verbose); break;
            default: return to_json(static_cast<std::underlying_type_t<OrderType>>(o), verbose); break;
        // clang-format on
        };
    }
    return to_json("", verbose);
}
```
